<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Demo account</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="company-description" content="Always respond in the same language as was written.">
  <style>
    body { background-color:#f9f9f9; font-family:Arial,sans-serif; height:100vh; margin:0; }

    /* Password gate */
    #gate { position:fixed; inset:0; background:#0b172033; display:flex; align-items:center; justify-content:center; z-index:9999; backdrop-filter:blur(6px); }
    .gate-card { background:#fff; width:90%; max-width:420px; padding:24px; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.15); text-align:center; }
    .gate-card h3 { margin:0 0 8px; color:#007b5e; }
    .gate-card p { margin:0 0 16px; color:#555; }
    .gate-card input[type="password"]{ width:100%; padding:12px; font-size:16px; border:1px solid #ccc; border-radius:8px; margin-bottom:12px; }
    .gate-card button{ width:100%; padding:12px; font-size:16px; border:none; border-radius:8px; background:#007b5e; color:#fff; cursor:pointer; }
    .gate-card button:hover{ background:#005c49; }
    .gate-error{ color:#c02727; min-height:22px; margin-top:8px; font-size:14px; }

    #app{ display:none; }

    /* App card */
    .wrap{ display:flex; flex-direction:column; align-items:center; justify-content:flex-start; padding-top:30px; }
    .chat-box{
      background:#fff; padding:30px; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,.1);
      width:90%; max-width:1100px; /* was 740px → iets wijder gemaakt */
      text-align:center; margin:30px auto;
    }
    img.logo{ width:150px; margin-bottom:10px; }
    h1{ color:#007b5e; margin:10px 0 5px 0; font-size:32px; }
    h2{ color:#555; margin:0 0 10px 0; font-size:16px; font-weight:normal; }

    /* (Oude farm-table styles verwijderd uit gebruik) */

    /* Controls */
    .field-wrap { width:90%; margin:0 auto 10px; text-align:left; }
    .field-wrap input,
    .field-wrap button,
    .field-wrap select {
      width:100%;
      padding:12px;
      font-size:16px;
      border:1px solid #ccc;
      border-radius:6px;
      box-sizing:border-box;
    }
    button{ background-color:#007b5e; color:#fff; cursor:pointer; }
    button:hover{ background-color:#005c49; }

    .control-row { width:90%; margin:4px auto 6px; display:flex; align-items:center; gap:10px; text-align:left; }
    .control-row input[type="checkbox"]{ width:auto; margin:0; }
    .control-row label{ font-size:14px; color:#555; user-select:none; }

    #presetWrap { display:none; }
    #presetSelect option[disabled] { color:#9aa0a6; }

    pre{
      margin:20px auto 0;
      text-align:left;
      background:#f0f0f0;
      padding:15px;
      border-radius:6px;
      white-space:pre-wrap;
      word-wrap:break-word;
      min-height:50px;
      width:100%; /* was 96% → volledig binnen de bredere kaart */
      box-sizing:border-box;
    }

    .download-row{
      display:none;
      width:100%;
      margin:8px auto 0;
      gap:8px;
      justify-content:flex-start;
      align-items:center;
      flex-wrap:wrap;
    }
    .small-btn{
      padding:8px 12px;
      font-size:14px;
      border-radius:6px;
      border:1px solid #0a6b55;
      background:#007b5e;
      color:#fff;
      cursor:pointer;
    }
    .small-btn:hover{ background:#005c49; }

    /* Hint onder UBN */
    .hint { font-size:13px; color:#4b5563; margin-top:6px; }
    .hint .ok { color:#065f46; }
    .hint .warn { color:#9a3412; }

    /* Preview blok */
    .file-preview{ margin-top:10px; text-align:left; font-size:14px; color:#374151; background:#f9fafb; border:1px dashed #d1d5db; padding:10px; border-radius:8px; }
    .file-preview img{ max-width:100%; height:auto; border-radius:6px; }

    @media (max-width: 640px) {
      .chat-box{ padding:20px; width:95%; }
      img.logo{ width:120px; }
      h1{ font-size:26px; }
      h2{ font-size:14px; }
      .field-wrap, .control-row{ width:100%; }
      pre{ width:100%; font-size:14px; }
      .download-row{ width:100%; }
    }

    /* caret + animaties */
    .typing-caret::after { content: "▍"; animation: blink 1s steps(1) infinite; }
    @keyframes blink { 50% { opacity: 0; } }
    .thinking::after { content: " ."; animation: dots 1.2s steps(3, end) infinite; }
    @keyframes dots {
      0% { content: " ."; }
      33% { content: " .."; }
      66% { content: " ..."; }
      100% { content: " ."; }
    }

    /* CSV editor */
    #csvEditorWrap{ display:none; margin-top:16px; text-align:left; }
    #csvEditorWrap h3{ margin:0 0 8px 0; color:#007b5e; }
    table.csv-edit{ width:100%; border-collapse:collapse; font-size:14px; }
    table.csv-edit th, table.csv-edit td{ border:1px solid #e5e7eb; padding:6px 8px; vertical-align:middle; }
    table.csv-edit th{ position:sticky; top:0; background:#f3f6f5; z-index:1; }
    table.csv-edit input[type="text"]{ width:100%; padding:6px; border:1px solid #d1d5db; border-radius:4px; box-sizing:border-box; }
    .yn-cell{ text-align:center; }
    .yn-cell input[type="checkbox"]{ transform:scale(1.2); }
    .editor-actions{ margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .status-chip{ font-size:13px; padding:6px 8px; border-radius:16px; background:#f1f5f9; color:#0f172a; display:none; }
    .status-chip.ok{ background:#e6f6f1; color:#065f46; }
    .status-chip.err{ background:#fdecec; color:#991b1b; }

    /* selectie style voor rij */
    .row-selected { background:#fff7ed !important; }
  </style>
</head>
<body>

  <!-- Password gate -->
  <div id="gate" aria-modal="true" role="dialog">
    <div class="gate-card">
      <h3>AHV secure demo</h3>
      <p>Enter the password to continue.</p>
      <input id="pw" type="password" placeholder="Password" autocomplete="current-password" />
      <button id="enter">Unlock</button>
      <div class="gate-error" id="gateError"></div>
    </div>
  </div>

  <!-- App -->
  <div id="app">
    <div class="wrap">
      <div class="chat-box">
        <img class="logo" src="ahv-logo.jpg" alt="AHV logo" />
        <h1>Demo account</h1>

        <!-- Intro -->
        <h2>In this demo, you can ask questions about the farm, cows, or sales data from the past 12 months..</h2>

        <!-- Nieuwe: Zoekbare dropdown met farms (op naam + country), zet UBN automatisch -->
        <div class="field-wrap" id="farmPickerWrap">
            <input id="farmSearch" placeholder="Type to filter… e.g. 'Smith', 'NL', 'FR'">
        </div>
        <div class="field-wrap">
          <select id="farmSelect" aria-label="Select a farm by name and country">
            <option value="">— Select a farm —</option>
          </select>
        </div>

        <div class="field-wrap">
          <input id="ubnInput" placeholder="Enter your UBN (farm registration number)..." inputmode="numeric" />
          <div id="farmNameHint" class="hint" aria-live="polite"></div>
          <div id="selectedFarmNote" class="hint"></div>
        </div>

        <!-- Free text (shown when presets are OFF) -->
        <div id="userInputWrap" class="field-wrap">
          <input id="userInput" placeholder="Please type your question in English, Dutch, German, or French and specify the relevant time period ..." />
        </div>

        <!-- Preset dropdown (shown when presets are ON) -->
        <div id="presetWrap" class="field-wrap">
          <select id="presetSelect" aria-label="Suggested questions">
            <option value="">— Choose a preset question —</option>
            <option value="Q1_CrossUpsell">Analyze the last 12 months of orders and herd data; identify missing product families and cross-sell or upsell opportunities.</option>
            <option value="Q2_SaleChanceThisMonth">Using last order date and revenue trends, estimate the chance of a new sale if I visit this month.</option>
            <option value="Q3_DryOff_20_25kg">From the latest MPR, what % of cows expected to dry off in the next 30 days are producing over 20 kg and over 25 kg milk?</option>
            <option value="Q4_FPR_Le60DIM">For cows ≤60 DIM in the latest MPR, what % have FPR ≥1.40 at first and second milk recording?</option>
            <option value="Q5_MilkCurve_0_100DIM">Show the herd’s average milk yield curve from calving to 100 DIM using the last 12 months of MPR data and note any >30% drops.</option>
            <option value="Q6_SCC_Bands_LatestMPR">In the latest MPR, how many cows have SCC >200k (heifers >100k)? Indicate chronic vs good-prognosis animals.</option>
            <option value="Q7_SCC_DryOff_vs_PostCalving">Compare SCC before dry-off and first SCC after calving for cows dried off in the last 6 months; summarize udder health changes.</option>
            <option value="Q8_FreshCows_0_100DIM">For cows ≤100 DIM in the latest MPR, compare milk yield vs expected, flag ketosis risk and FPR ≥1.40, and mark ≥30% milk drops.</option>
            <option value="Q9_DryOff_3Months">How many cows are due to dry off in the next 3 months and what is their current milk yield?</option>
            <option value="Q10_RiskLists">Create three lists from the latest MPR: metabolic risk, active udder protocol need (DIM 7–100 & SCC ≥100k), and dry-off risk (milk >20kg and/or SCC >200k) within 30 days.</option>
          </select>
        </div>

        <!-- Toggle BELOW whichever input is shown -->
        <div class="control-row">
          <input type="checkbox" id="togglePresets" />
          <label for="togglePresets">Show suggested questions</label>
        </div>

        <div class="field-wrap">
          <button onclick="sendToGPT()" id="sendBtn">Send</button>
        </div>

        <pre id="response">Answer will appear here...</pre>

        <!-- Download buttons (hidden until final response exists) -->
        <div class="download-row" id="downloadRow">
          <button class="small-btn" onclick="downloadDocx()">Download .docx</button>
          <button class="small-btn" onclick="downloadPDF()">Download PDF</button>
        </div>
      </div>

      <!-- Use case 3: AHV / Foto Upload Sectie -->
      <div class="chat-box" id="photoBox">
        <h2>Upload a photo of the completed treatment card using your phone</h2>
        <div class="field-wrap">
          <input type="file" id="imageUpload" accept="image/png,image/jpeg" />
        </div>
        <div class="field-wrap">
          <button onclick="uploadImage()" id="imageBtn">Verstuur</button>
        </div>
        <pre id="imageResponse">Answer will appear here...</pre>
        <!-- Hidden until output is created -->
        <button id="openEditorFromImage" class="small-btn" style="display:none;">Open editor</button>

        <div class="file-preview" id="filePreview"></div>

        <!-- CSV Editor -->
        <div id="csvEditorWrap">
          <h3>Behandelkaart (bewerken & bevestigen)</h3>
          <div class="field-wrap">
            <div style="max-height:420px; overflow:auto; border:1px solid #e5e7eb; border-radius:8px;">
              <table id="csvEditorTable" class="csv-edit" aria-label="Behandelkaart editor"></table>
            </div>
            <div class="editor-actions">
              <button id="addRowBtn" class="small-btn" style="background:#2563eb; border-color:#1d4ed8;">Add row</button>
              <button id="deleteRowBtn" class="small-btn" style="background:#ef4444; border-color:#dc2626;">Delete row</button>
              <button id="confirmCsvBtn" class="small-btn">Confirm (download CSV)</button>
              <button id="submitCsvBtn" class="small-btn" style="background:#0b5; border-color:#0a6b55;">Submit treatment record</button>
              <span id="submitStatus" class="status-chip">Status</span>
              <button id="cancelCsvBtn" class="small-btn" style="background:#6b7280; border-color:#6b7280;">Cancel</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- DOCX + PDF helpers -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
    const PASS_HASH = "234f1d8746bbd3d0b3a236243b96f8c353c7625c4af41f3d86aac4f239a7e2d0"; // SHA-256 of "AHVDemo123!"

    // Scenario URLs
    const SCENARIO2_URL = "https://hook.eu2.make.com/8dm926y2ted2rqsh7m5ggqg0r6qehfz1";
    const SCENARIO1_URL = "https://hook.eu2.make.com/u2luxbx3o1wihpsbysz8gelret1x0jze";
    const PHOTO_URL = SCENARIO1_URL; // foto-upload gebruikt zelfde endpoint als use case 1

    // Corrections (treatment record) webhook
    const CORRECTION_URL = "https://hook.eu2.make.com/n16792joe3us6eo41o4x9efbj9r582c6";

    const TYPE_SPEED = 25;
    const TYPE_SPEED_S2 = 40;
    let runIdCounter = 0;
    let currentRunId = 0;

    /* =========================
       UBN → Farm name (CSV)
       ========================= */
    const CSV_PATH = "CountryCodes (6).csv"; // zelfde map als index.html
    const FARM_INDEX = new Map(); // key: ubn, value: {name, country}
    let FARMS = []; // [{ubn, name, country}]

    function parseCSV(text) {
      const rows = [];
      let i = 0, field = "", row = [], inQuotes = false;
      while (i < text.length) {
        const ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          } else { field += ch; i++; continue; }
        } else {
          if (ch === '"') { inQuotes = true; i++; continue; }
          if (ch === ',') { row.push(field); field = ""; i++; continue; }
          if (ch === '\n' || ch === '\r') {
            if (ch === '\r' && text[i + 1] === '\n') i++;
            row.push(field); rows.push(row); field = ""; row = []; i++; continue;
          }
          field += ch; i++;
        }
      }
      if (field.length || row.length) { row.push(field); rows.push(row); }
      return rows;
    }

    function normalizeUBN(v) {
      return String(v ?? "").replace(/[^\d]/g, "");
    }

    async function buildFarmIndex() {
      try {
        const res = await fetch(CSV_PATH, { cache: "no-store" });
        if (!res.ok) throw new Error("CSV not found");
        const text = await res.text();
        const rows = parseCSV(text).filter(r => r.length && r.some(x => x && String(x).trim().length));
        if (!rows.length) return;

        const header = rows[0].map(h => String(h).trim().toLowerCase());
        const ubnIdx   = header.indexOf("ubn");
        const nameIdx  = header.indexOf("farm_name");
        const ccIdx    = header.indexOf("country_code");
        const nameIdxAlt = nameIdx >= 0 ? nameIdx : header.findIndex(h => /name/i.test(h));
        const ubnIdxAlt  = ubnIdx  >= 0 ? ubnIdx  : header.findIndex(h => /ubn|id|identifier/i.test(h));

        const u = ubnIdx >= 0 ? ubnIdx : ubnIdxAlt;
        const n = nameIdx >= 0 ? nameIdx : nameIdxAlt;

        FARMS = [];
        for (let r = 1; r < rows.length; r++) {
          const cells = rows[r];
          const key = normalizeUBN(cells[u] ?? "");
          const name = (cells[n] ?? "").toString().trim();
          const country = ccIdx >= 0 ? (cells[ccIdx] ?? "").toString().trim() : "";
          if (key) {
            FARM_INDEX.set(key, { name, country });
            FARMS.push({ ubn: key, name, country });
          }
        }
        populateFarmSelect(FARMS);
      } catch (e) {
        console.warn("Farm index build failed:", e);
      }
    }

    function showFarmNameForUBN(rawUBN) {
      const hint = document.getElementById("farmNameHint");
      const key = normalizeUBN(rawUBN);
      if (!key) { hint.textContent = ""; return; }

     }

    // === nieuwe helpers: dropdown + search ===
    function optionLabel(f) {
      return `${f.name}${f.country ? " — " + f.country : ""}`;
    }

    function populateFarmSelect(list){
      const sel = document.getElementById("farmSelect");
      sel.innerHTML = `<option value="">— Select a farm —</option>`;
      const frag = document.createDocumentFragment();
      list.forEach(f => {
        const opt = document.createElement("option");
        opt.value = f.ubn;               // waarde = UBN
        opt.textContent = optionLabel(f); // getoond: "Naam — CC"
        frag.appendChild(opt);
      });
      sel.appendChild(frag);
    }

    function filterFarms(query){
      const q = (query || "").trim().toLowerCase();
      if (!q) { populateFarmSelect(FARMS); return; }
      const filtered = FARMS.filter(f => {
        const label = optionLabel(f).toLowerCase();
        return label.includes(q) || f.ubn.includes(q);
      });
      populateFarmSelect(filtered);
    }

    // init
    buildFarmIndex();

    async function sha256Hex(str) {
      const buf = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", buf);
      return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2,"0")).join("");
    }

    async function unlock() {
      const pw = document.getElementById("pw").value || "";
      const err = document.getElementById("gateError");
      const hex = await sha256Hex(pw);
      if (hex === PASS_HASH) {
        document.getElementById("gate").style.display = "none";
        document.getElementById("app").style.display = "block";
        setTimeout(() => {
          const t = document.getElementById("togglePresets").checked;
          (t ? document.getElementById("presetSelect") : document.getElementById("userInput")).focus();
        }, 0);
      } else {
        err.textContent = "Incorrect password.";
      }
    }
    document.getElementById("enter").addEventListener("click", unlock);
    document.getElementById("pw").addEventListener("keydown", e => { if (e.key === "Enter") unlock(); });

    const togglePresets = document.getElementById("togglePresets");
    const presetWrap   = document.getElementById("presetWrap");
    const presetSelect = document.getElementById("presetSelect");
    const userInputWrap= document.getElementById("userInputWrap");
    const userInputEl  = document.getElementById("userInput");
    const ubnInputEl   = document.getElementById("ubnInput");

    function updateMode() {
      const on = togglePresets.checked;
      presetWrap.style.display   = on ? "block" : "none";
      userInputWrap.style.display= on ? "none"  : "block";
      if (on) { userInputEl.value = ""; presetSelect.focus(); }
      else    { presetSelect.value = ""; userInputEl.focus(); }
    }
    togglePresets.addEventListener("change", updateMode);

    ubnInputEl.addEventListener("input", (e) => showFarmNameForUBN(e.target.value));
    ubnInputEl.addEventListener("blur", (e) => showFarmNameForUBN(e.target.value));

    // events: farm search + select → zet UBN & note
    const farmSearchEl = document.getElementById("farmSearch");
    const farmSelectEl = document.getElementById("farmSelect");
    const selectedFarmNoteEl = document.getElementById("selectedFarmNote");

    farmSearchEl.addEventListener("input", (e) => {
      filterFarms(e.target.value);
    });

    farmSelectEl.addEventListener("change", (e) => {
      const ubn = normalizeUBN(e.target.value || "");
      if (!ubn) {
        selectedFarmNoteEl.textContent = "";
        return;
      }
      // zet UBN veld
      ubnInputEl.value = ubn;
      // toon hint
      showFarmNameForUBN(ubn);
      // toon naam + CC + UBN onder dropdown
      const rec = FARM_INDEX.get(ubn);
      if (rec) {
        selectedFarmNoteEl.innerHTML = `<span class="ok">Selected: ${rec.name}${rec.country ? " — " + rec.country : ""} (UBN: ${ubn})</span>`;
      } else {
        selectedFarmNoteEl.textContent = "";
      }
    });

    /* ===== Tekst helpers voor animaties ===== */
    function showFinishing(el, prefixText = "") {
      const base = prefixText ? (prefixText + "\n\n") : "";
      el.textContent = base + "Finishing";
      el.classList.add("thinking");
    }
    function clearThinking(el) {
      el.classList.remove("thinking");
    }
    function startAnalyzingCountdown(el, seconds, prefixText = "", onDone) {
      let s = seconds;
      const base = prefixText ? (prefixText + "\n\n") : "";
      el.classList.add("thinking");
      el.textContent = base + `Analyzing (${s}s)`;
      const id = setInterval(() => {
        s--;
        if (s > 0) {
          el.textContent = base + `Analyzing (${s}s)`;
        } else {
          clearInterval(id);
          if (typeof onDone === "function") onDone();
          else showFinishing(el, prefixText);
        }
      }, 1000);
      return id;
    }
    async function typeOut(text, el, opts = {}) {
      const speed = opts.speed ?? 25;
      const clear = opts.clear ?? true;
      const content = String(text ?? "");
      if (clear) el.textContent = "";
      el.classList.add("typing-caret");
      const lines = content.split(/\n/);
      for (let i = 0; i < lines.length; i++) {
        const tokens = lines[i].split(/(\s+)/);
        for (const t of tokens) {
          el.textContent += t;
          await new Promise(r => setTimeout(r, speed));
        }
        if (i < lines.length - 1) {
          el.textContent += "\n";
          await new Promise(r => setTimeout(r, speed * 6));
        }
      }
      el.classList.remove("typing-caret");
    }
    function stripJsonBlocks(raw){
      if (!raw) return "";
      let t = String(raw);
      t = t.replace(/```[\s\S]*?```/g, "");
      function stripBalancedJson(s, open, close){
        let out = "", depth = 0, buf = "";
        for (let i = 0; i < s.length; i++){
          const ch = s[i];
          if (ch === open){
            if (depth++ === 0){ buf = ""; continue; }
          } else if (ch === close && depth > 0){
            if (--depth === 0){
              const content = buf;
              const looksJson = content.includes(":") && content.replace(/\s/g,"").length > 40;
              if (!looksJson) out += open + content + close;
              continue;
            }
          }
          if (depth > 0) buf += ch; else out += ch;
        }
        return out;
      }
      t = stripBalancedJson(t, "{", "}");
      t = stripBalancedJson(t, "[", "]");
      t = t.split("\n").filter(line => {
        const trimmed = line.trim();
        const looksInlineJson = (/^(\{|\[).*(\:).*(\}|\])$/.test(trimmed) && trimmed.length > 20);
        return !looksInlineJson;
      }).join("\n");
      t = t.replace(/[ \t]*,\s*\n/g, "\n");
      t = t.replace(/\n{3,}/g, "\n\n");
      return t.trim();
    }
    async function fetchText(url, payload){
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      return await res.text();
    }

    /* ===== CSV extraction helpers ===== */
    function extractCsvFromWebhookRaw(rawText){
      try {
        const arr = JSON.parse(rawText);
        const entry = Array.isArray(arr) ? (arr[0] || {}) : {};
        const textField = entry.text ?? entry.body ?? entry.data ?? entry.json ?? null;
        if (typeof textField === "string") {
          const inner = textField;
          const m1 = inner.match(/```csv\s*([\s\S]*?)```/i);
          if (m1 && m1[1]) return m1[1].trim();
          try {
            const asObj = JSON.parse(inner);
            const content = asObj?.choices?.[0]?.message?.content ?? "";
            const m2 = content.match(/```csv\s*([\s\S]*?)```/i);
            if (m2 && m2[1]) return m2[1].trim();
            if (content && /^[^\r\n]*,[^\r\n]*$/.test(content.split("\n")[0] || "")) return content.trim();
          } catch {}
          if (inner && /^[^\r\n]*,[^\r\n]*$/.test((inner.split("\n")[0] || ""))) return inner.trim();
        }
      } catch {}
      try {
        const obj = JSON.parse(rawText);
        const content = obj?.choices?.[0]?.message?.content ?? "";
        const m = content.match(/```csv\s*([\s\S]*?)```/i);
        if (m && m[1]) return m[1].trim();
        if (content && /^[^\r\n]*,[^\r\n]*$/.test(content.split("\n")[0] || "")) return content.trim();
      } catch {}
      const m3 = rawText.match(/```csv\s*([\s\S]*?)```/i);
      if (m3 && m3[1]) return m3[1].trim();
      return "";
    }
    function csvToMatrix(csv){
      const rows = parseCSV(csv);
      return rows.filter(r => r.some(c => String(c||"").trim().length));
    }
    function matrixToCSV(matrix){
      const esc = v => {
        const s = String(v ?? "");
        if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
        return s;
      };
      return matrix.map(row => row.map(esc).join(",")).join("\n");
    }

    // --- CSV editor state ---
    let CSV_MATRIX = null;
    let CSV_HEADERS = null;
    let SELECTED_ROW_INDEX = null; // 1-based (1 = eerste data-rij), 0 = header

    const NON_TOGGLE_COLUMNS = new Set(["KOE NUMMER","DATUM","OPMERKINGEN"]);

    function bindRowSelection(tr, dataRowIndex){ // dataRowIndex = r (1..n) corresponderend met CSV_MATRIX
      tr.addEventListener("click", () => {
        const tbody = tr.parentElement;
        [...tbody.children].forEach(row => row.classList.remove("row-selected"));
        tr.classList.add("row-selected");
        SELECTED_ROW_INDEX = dataRowIndex;
      });
    }

    function renderCsvEditor(matrix){
      if (!matrix || !matrix.length) return;
      const wrap = document.getElementById("csvEditorWrap");
      const table = document.getElementById("csvEditorTable");
      table.innerHTML = "";

      CSV_MATRIX = matrix.map(r => [...r]); // clone
      CSV_HEADERS = CSV_MATRIX[0].map(h => String(h).trim());
      SELECTED_ROW_INDEX = null;

      // Thead
      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      CSV_HEADERS.forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      table.appendChild(thead);

      // Tbody
      const tbody = document.createElement("tbody");
      for (let r = 1; r < CSV_MATRIX.length; r++){
        const tr = document.createElement("tr");
        CSV_HEADERS.forEach((h, cIdx) => {
          const td = document.createElement("td");
          if (!NON_TOGGLE_COLUMNS.has(h)) {
            const val = String(CSV_MATRIX[r][cIdx] ?? "").trim().toUpperCase();
            const checked = (val === "JA");
            td.className = "yn-cell";
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.checked = checked;
            cb.addEventListener("change", () => {
              CSV_MATRIX[r][cIdx] = cb.checked ? "JA" : "NEE";
            });
            td.appendChild(cb);
          } else {
            const inp = document.createElement("input");
            inp.type = "text";
            inp.value = CSV_MATRIX[r][cIdx] ?? "";
            inp.addEventListener("input", () => {
              CSV_MATRIX[r][cIdx] = inp.value;
            });
            td.appendChild(inp);
          }
          tr.appendChild(td);
        });
        bindRowSelection(tr, r);
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);

      // Buttons + actions
      const statusEl = document.getElementById("submitStatus");
      statusEl.style.display = "none";
      statusEl.className = "status-chip";

      // Add row handler
      document.getElementById("addRowBtn").onclick = () => {
        if (!CSV_HEADERS) return;
        const newRow = CSV_HEADERS.map(h => NON_TOGGLE_COLUMNS.has(h) ? "" : "NEE");
        CSV_MATRIX.push(newRow);

        const tr = document.createElement("tr");
        CSV_HEADERS.forEach((h, cIdx) => {
          const td = document.createElement("td");
          if (!NON_TOGGLE_COLUMNS.has(h)) {
            td.className = "yn-cell";
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.checked = false; // "NEE"
            cb.addEventListener("change", () => {
              CSV_MATRIX[CSV_MATRIX.length - 1][cIdx] = cb.checked ? "JA" : "NEE";
            });
            td.appendChild(cb);
          } else {
            const inp = document.createElement("input");
            inp.type = "text";
            inp.value = "";
            inp.addEventListener("input", (e) => {
              CSV_MATRIX[CSV_MATRIX.length - 1][cIdx] = e.target.value;
            });
            td.appendChild(inp);
          }
          tr.appendChild(td);
        });
        bindRowSelection(tr, CSV_MATRIX.length - 1);
        table.querySelector("tbody").appendChild(tr);
      };

      // Delete row handler (verwijdert geselecteerde data-rij)
      document.getElementById("deleteRowBtn").onclick = () => {
        if (SELECTED_ROW_INDEX === null || SELECTED_ROW_INDEX <= 0) {
          alert("Select a data row to delete.");
          return;
        }
        if (SELECTED_ROW_INDEX === 0) {
          alert("Header cannot be deleted.");
          return;
        }
        CSV_MATRIX.splice(SELECTED_ROW_INDEX, 1);
        const tbodyEl = table.querySelector("tbody");
        if (tbodyEl && tbodyEl.rows[SELECTED_ROW_INDEX - 1]) {
          tbodyEl.deleteRow(SELECTED_ROW_INDEX - 1);
        }
        SELECTED_ROW_INDEX = null;
      };

      document.getElementById("confirmCsvBtn").onclick = () => {
        const finalCsv = matrixToCSV(CSV_MATRIX);
        const blob = new Blob([finalCsv], { type: "text/csv;charset=utf-8" });
        saveAs(blob, "behandelkaart.csv");
      };

      document.getElementById("submitCsvBtn").onclick = async () => {
        const ubn = normalizeUBN(document.getElementById("ubnInput").value);
        const finalCsv = matrixToCSV(CSV_MATRIX);
        await submitCorrections(finalCsv, ubn, statusEl);
      };

      document.getElementById("cancelCsvBtn").onclick = () => {
        wrap.style.display = "none";
      };

      wrap.style.display = "block";
    }

    /* Robust submit with fallback & diagnostics  */
    async function submitCorrections(csvText, ubn, statusEl){
      statusEl.style.display = "inline-block";
      statusEl.textContent = "Submitting...";
      statusEl.className = "status-chip";

      const requestId = (crypto && crypto.randomUUID)
        ? crypto.randomUUID()
        : (Date.now().toString(36) + Math.random().toString(36).slice(2));

      const basePayload = {
        type: "treatment_record",
        request_id: requestId,
        ubn: ubn || undefined,
        corrected_csv: csvText
      };

      async function assertOk(res){
        const bodyText = await res.text();
        if (!res.ok) {
          const msg = `HTTP ${res.status} ${res.statusText} — ${bodyText.slice(0, 500)}`;
          throw new Error(msg);
        }
        return bodyText;
      }

      // Try JSON
      try {
        const res = await fetch(CORRECTION_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Accept": "application/json" },
          body: JSON.stringify(basePayload)
        });
        await assertOk(res);
        statusEl.textContent = "Submitted ✓";
        statusEl.className = "status-chip ok";
        return;
      } catch (e1) {
        console.warn("JSON submit failed, retry as form-data:", e1);
      }

      // Fallback: multipart/form-data
      try {
        const fd = new FormData();
        fd.append("type", "treatment_record");
        fd.append("request_id", requestId);
        fd.append("ubn", ubn || "");
        fd.append("corrected_csv", csvText);

        const res2 = await fetch(CORRECTION_URL, { method: "POST", body: fd });
        await assertOk(res2);
        statusEl.textContent = "Submitted ✓ (form-data)";
        statusEl.className = "status-chip ok";
        return;
      } catch (e2) {
        statusEl.textContent = "Failed: " + e2.message;
        statusEl.className = "status-chip err";
      }
    }

    /* ===============================
       Parallel flow S2/S1 + CSV editor
       =============================== */
    async function sendToGPT() {
      const usingPreset = togglePresets.checked;
      const preset_id   = usingPreset ? (presetSelect.value || "") : null;
      const preset_text = usingPreset ? (presetSelect.options[presetSelect.selectedIndex]?.text || "") : null;

      const message = usingPreset ? (preset_text || "").trim()
                                  : (userInputEl.value || "").trim();
      const messageMultipleField = usingPreset ? preset_text : null;

      const ubnRaw = document.getElementById("ubnInput").value;
      const ubn = normalizeUBN(ubnRaw);
      const responseEl = document.getElementById("response");
      const dlRow = document.getElementById("downloadRow");
      const sendBtn = document.getElementById("sendBtn");

      currentRunId = ++runIdCounter;
      const myRunId = currentRunId;
      responseEl.textContent = "";
      clearThinking(responseEl);
      dlRow.style.display = "none";
      sendBtn.disabled = true;

      const requestId = (crypto && crypto.randomUUID)
        ? crypto.randomUUID()
        : (Date.now().toString(36) + Math.random().toString(36).slice(2));

      try {
        const payload = {
          company_name: "TestAccount",
          company_description: document.querySelector('meta[name="company-description"]').content,
          message,
          messageMultipleField,
          question_mode: usingPreset ? "preset" : "free",
          preset_id,
          preset_text,
          ubn: ubn || undefined,
          request_id: requestId
        };

        let s2Resolved = false;
        const s2Promise = fetchText(SCENARIO2_URL, payload).then(txt => { s2Resolved = true; return txt; });
        const s1Promise = fetchText(SCENARIO1_URL, payload);

        const preCountdownId = startAnalyzingCountdown(
          responseEl,
          5,
          "",
          () => { if (myRunId === currentRunId && !s2Resolved) showFinishing(responseEl); }
        );

        // S2
        const s2Raw = await s2Promise;
        if (myRunId !== currentRunId) return;

        clearInterval(preCountdownId);
        clearThinking(responseEl);

        const s2Show = stripJsonBlocks(s2Raw);
        await typeOut(s2Show, responseEl, { clear: true, speed: TYPE_SPEED_S2 });

        tryRenderCsvFromReply(s2Raw);

        if (myRunId !== currentRunId) return;
        const wait10Id = startAnalyzingCountdown(
          responseEl,
          10,
          s2Show,
          () => { if (myRunId === currentRunId) showFinishing(responseEl, s2Show); }
        );

        const s1Raw = await s1Promise;
        if (myRunId !== currentRunId) { clearInterval(wait10Id); return; }

        clearInterval(wait10Id);
        clearThinking(responseEl);

        responseEl.textContent = s2Show + "\n\n";
        const s1Show = stripJsonBlocks(s1Raw);
        await typeOut(s1Show, responseEl, { clear: false, speed: TYPE_SPEED });

        tryRenderCsvFromReply(s1Raw);

        dlRow.style.display = "flex";

      } catch (err) {
        if (myRunId !== currentRunId) return;
        clearThinking(responseEl);
        responseEl.textContent = "Error: " + err.message;
      } finally {
        if (myRunId === currentRunId) sendBtn.disabled = false;
      }
    }

    function tryRenderCsvFromReply(rawReply){
      const csv = extractCsvFromWebhookRaw(rawReply);
      if (csv) {
        const matrix = csvToMatrix(csv);
        if (matrix && matrix.length > 1) {
          renderCsvEditor(matrix);
          return true;
        }
      }
      document.getElementById("csvEditorWrap").style.display = "none";
      return false;
    }

    // --- Download helpers ---
    function downloadDocx() {
      const { Document, Packer, Paragraph, TextRun } = docx;
      const text = (document.getElementById("response").innerText || "").replace(/\r\n/g, "\n");
      const paragraphs = text.split("\n").map(line => new Paragraph({ children: [new TextRun(line)] }));
      const doc = new Document({ sections: [{ properties: {}, children: paragraphs.length ? paragraphs : [new Paragraph("")] }]});
      Packer.toBlob(doc).then(blob => saveAs(blob, "answer.docx"));
    }

    function downloadPDF() {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit:"pt", format:"a4" });
      const text = (document.getElementById("response").innerText || "");
      const margin = 40;
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const maxWidth = pageWidth - margin * 2;
      const lines = doc.splitTextToSize(text, maxWidth);
      let y = margin;
      const lineHeight = 16;

      lines.forEach(line => {
        if (y > pageHeight - margin) { doc.addPage(); y = margin; }
        doc.text(line, margin, y);
        y += lineHeight;
      });

      doc.save("answer.pdf");
    }

    /* ===============================
       Use case 3: Foto upload (JPEG/PNG)
       =============================== */
    async function uploadImage() {
      const fileInput = document.getElementById("imageUpload");
      const file = fileInput.files && fileInput.files[0];
      const previewEl = document.getElementById("filePreview");
      const responseEl = document.getElementById("imageResponse");
      const btn = document.getElementById("imageBtn");
      const openBtn = document.getElementById("openEditorFromImage");

      openBtn.style.display = "none";

      if (!file) {
        responseEl.innerText = "Geen bestand geselecteerd.";
        return;
      }

      const isAllowedType = /image\/jpeg|image\/png/i.test(file.type)
        || /\.(jpe?g|png)$/i.test(file.name);
      if (!isAllowedType) {
        responseEl.innerText = "Alleen JPEG of PNG is toegestaan.";
        return;
      }

      const reader = new FileReader();
      btn.disabled = true;

      reader.onload = async function(e) {
        const base64Image = e.target.result; // data URL
        /* ▼▼ AANGEPAST: engels tekst ▼▼ */
        previewEl.innerHTML = `<strong>Your upload:</strong><br><img src="${base64Image}" alt="Upload preview" />`;

        const ubn = normalizeUBN(document.getElementById("ubnInput").value);
        const requestId = (crypto && crypto.randomUUID)
          ? crypto.randomUUID()
          : (Date.now().toString(36) + Math.random().toString(36).slice(2));

        // 40s countdown
        let replyResolved = false;
        const countdownId = startAnalyzingCountdown(
          responseEl,
          40,
          "",
          () => { if (!replyResolved) showFinishing(responseEl); }
        );

        document.getElementById("csvEditorWrap").style.display = "none";

        try {
          const payload = {
            company_name: "TestAccount",
            company_description: document.querySelector('meta[name="company-description"]').content,
            message: "Afbeelding geüpload",
            ubn: ubn || undefined,
            request_id: requestId,
            uploaded_image: base64Image
          };

          const reply = await fetchText(PHOTO_URL, payload);
          replyResolved = true;
          clearInterval(countdownId);
          clearThinking(responseEl);

          responseEl.innerText = stripJsonBlocks(reply) || "Geen antwoord ontvangen.";

          openBtn.style.display = "inline-block";

          const ok = tryRenderCsvFromReply(reply);
          if (!ok) {
            document.getElementById("csvEditorWrap").style.display = "none";
          }
        } catch (err) {
          replyResolved = true;
          clearInterval(countdownId);
          clearThinking(responseEl);
          responseEl.innerText = "Fout: " + err.message;
          openBtn.style.display = "none";
          document.getElementById("csvEditorWrap").style.display = "none";
        } finally {
          btn.disabled = false;
        }
      };

      reader.readAsDataURL(file);
    }
  </script>

  <!-- Handmatige editor openen op basis van getoonde output -->
  <script>
    function openEditorFrom(preId){
      const raw = document.getElementById(preId)?.innerText || "";
      const csv = extractCsvFromWebhookRaw(raw) || raw;
      const matrix = csvToMatrix(csv);
      if (matrix && matrix.length > 1) {
        renderCsvEditor(matrix);
        document.getElementById("csvEditorWrap").scrollIntoView({ behavior: "smooth" });
      } else {
        alert("Geen CSV gevonden om te bewerken.");
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      const btnImg = document.getElementById("openEditorFromImage");
      if (btnImg) btnImg.onclick = () => openEditorFrom("imageResponse");
    });
  </script>
</body>
</html>





